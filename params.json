{"name":"Rosie","tagline":"Rosie is an Android framework to create applications following the principles of Clean Architecture.","body":"![Karumi logo][karumilogo]Rosie [![Build Status](https://travis-ci.org/Karumi/Rosie.svg?branch=master)](https://travis-ci.org/Karumi/Rosie) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.karumi.rosie/rosie/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.karumi.rosie/rosie)\r\n======\r\n\r\n> The only way to make the deadline—the only way to go fast—is to keep the code as clean as possible at all times.\r\n\r\n> &mdash; <cite> Robert C. Martin in [Clean Code: A Handbook of Agile Software Craftsmanship](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)</cite>\r\n\r\nIntroduction\r\n------------\r\n\r\nRosie is an Android framework to create applications following the principles of [Clean Architecture][clean].\r\n\r\nRosie divides your application in three layers, **view**, **domain** and **repository**. For each layer, Rosie provides plenty of classes that will make defining and separating these concerns much easier.\r\n\r\n* **View**: It contains all your presentation logic, implemented through the [Model-View-Presenter pattern][mvp]. Rosie provides classes to represent the main components of this layer like ``RosieActivity``, ``RosieFragment`` or ``RosiePresenter``.\r\n* **Domain**: Holding all your business logic, its main component is ``RosieUseCase`` that gives you an easy way to define your application use cases and execute them in a background thread using the [command pattern][com].\r\n* **Repository**: This layer gives you an abstraction of how to retrieve and store data in your application following the [Repository pattern][rep]. ``RosieRepository`` and the multiple ``DataSource`` classes gives you the base to start building your own repositories.\r\n\r\nFinally, Rosie comes with Dagger to solve Dependency inversion through [Dependency Injection][di].\r\n\r\nScreenshots\r\n-----------\r\n\r\n![Screencast](./art/screencast.gif)\r\n\r\nUsage\r\n-----\r\n\r\nFirst thing you will need to do is to make your own ``Application`` instance extend ``RosieApplication`` in order to provide your global dependencies module to Dagger:\r\n\r\n```java\r\npublic class SampleApplication extends RosieApplication {\r\n\t@Override protected List<Object> getApplicationModules() {\r\n\t\treturn Arrays.asList((Object) new SampleGlobalModule());\r\n\t}\r\n}\r\n```\r\n\r\n\r\nRosie provides several base classes to start implementing your architecture separated in three layers, **view**, **domain** and **repository**. Let's explore them in detail.\r\n\r\n###View\r\nThe view package contains all the classes needed to implement your presentation logic following the MVP pattern. To use the view package, make your ``Activity`` extend from ``RosieActivity`` or your ``Fragment`` from ``RosieFragment`` and specify the layout that Rosie will automatically inflate for you:\r\n\r\n```java\r\npublic class SampleActivity extends RosieActivity {\r\n\t@Override protected int getLayoutId() {return R.layout.sample_activity;}\r\n\t/*...*/\r\n}\r\n```\r\n\r\n####Butter Knife\r\n\r\nBy extending Rosie view classes, you will have access in your activities and fragments to [ButterKnife] [butterknife] annotations to easily inject your views:\r\n\r\n```java\r\npublic class SampleActivity extends RosieActivity {\r\n\t@Bind(R.id.sample_view) TextView sampleView;\r\n\t/*...*/\r\n}\r\n```\r\n\r\n####Dagger\r\n\r\nBesides, you can define the [Dagger] [dagger] module that will contain the dependencies for your activity by overriding the ``getActivityScopeModules`` method:\r\n\r\n```java\r\npublic class SampleActivity extends RosieActivity {\r\n\t@Override protected List<Object> getActivityScopeModules() {\r\n\t\treturn Arrays.asList((Object) new SampleModule());\r\n\t}\r\n\t/*...*/\r\n}\r\n```\r\n\r\nThere is also two useful annotations to provide ``Context`` dependencies into your classes, one for your ``Application`` context and one for your current ``Activity``:\r\n\r\n```java\r\npublic class InjectedClass {\r\n\t@Inject public InjectedClass(@ForApplication Context applicationContext, @ForActivity Context activityContext) {\r\n\t\t/*...*/\r\n\t}\r\n}\r\n```\r\n\r\n####Presenter\r\nTo follow the MVP pattern, Rosie provides a ``RosiePresenter`` class that will be responsible for all your presentation logic. Rosie will take care of linking your view (a ``RosieActivity`` or ``RosieFragment`` implementation) with your presenter and subscribing it to its lifecycle. In order to do that, create a ``RosiePresenter`` and inject it into your activity/fragment with the ``@Presenter`` annotation:\r\n\r\n```java\r\npublic class SamplePresenter extends RosiePresenter<SamplePresenter.View> {\r\n\tpublic interface View extends RosiePresenter.View {\r\n\t\t/*...*/\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\npublic class SampleActivity extends RosieActivity implements SamplePresenter.View {\r\n\t@Inject @Presenter SamplePresenter presenter;\r\n\t@Override protected void onPreparePresenter() {/*...*/}\r\n}\r\n```\r\n\r\nOnce both, view and presenter, are linked you can react to your view lifecycle directly from the presenter. The ``onPreparePresenter`` method gives you the opportunity to configure your presenter before any of these methods are called (e.g. with your intent parameters). You will be also able to call your view easily from the presenter:\r\n\r\n```java\r\npublic class SamplePresenter extends RosiePresenter<SamplePresenter.View> {\r\n\tprotected void initialize() {/*...*/}\r\n\tprotected void update() {/*...*/}\r\n\tprotected void pause() {/*...*/}\r\n\tprotected void destroy() {/*...*/}\r\n\t\r\n\tprivate void sampleMethod() {\r\n\t\tView view = getView(); // Get the view linked to the presenter\r\n\t\tview.foo();\r\n\t}\r\n\t\r\n\tpublic interface View extends RosiePresenter.View {\r\n\t\tvoid foo();\r\n\t}\r\n}\r\n```\r\n\r\nTo understand when the lifecycle methods are called take a look at the following table:\r\n\r\n| RosiePresenter  | Activity       | Fragment           |\r\n| --------------- |----------------| -------------------|\r\n| ``initialize``  | ``onCreate``   | ``onViewCreated``  |\r\n| ``update``      | ``onResume``   | ``onResume``       |\r\n| ``pause``       | ``onPause``    | ``onPause``        |\r\n| ``destroy``     | ``onDestroy``  | ``onDestroy``      |\r\n\r\n####Renderers\r\n\r\nFinally, Rosie includes the [Renderers] [renderers] library to simplify your ``RecyclerView`` handling code. If you decide to use Renderers, remember to extend directly from ``RosieRenderer<T>`` to have ButterKnife injections for free in your renderer views.\r\n\r\n###Domain\r\n\r\nThe domain package is meant to contain all your business logic that will change from app to app. For that reason, Rosie only provides a single ``RosieUseCase`` class that will help you execute your use cases in background following the command pattern.\r\n\r\nTo start using the Rosie domain package, create your use cases extending ``RosieUseCase`` and define the method containing your use case logic. Remember to call ``notifySuccess`` or ``notifyError`` to get results back to your presenter:\r\n\r\n```java\r\npublic class DoSomething extends RosieUseCase {\r\n\t@UseCase public void doSomething(Object arg) {\r\n\t\tObject response = getData();\r\n\t\tif (response.isOk()) {\r\n\t\t\tnotifySuccess(response.getContent());\r\n\t\t} else {\r\n\t\t\tnotifyError(response.getError());\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nTo call your use case, create a ``UseCaseCall``, configure it and execute it. Rosie gives you a fluent API to easily do this from your presenters:\r\n\r\n```java\r\npublic class SamplePresenter extends RosiePresenter<SamplePresenter.View> {\r\n\tpublic void callUseCase() {\r\n\t\tcreateUseCaseCall(doSomething)\r\n\t\t\t.args(arg /*, arg2, arg3, ...*/)\r\n\t\t\t.onSuccess(new OnSuccessCallback() {\r\n\t\t\t\t/*...*/\r\n\t\t\t})\r\n\t\t\t.onError(new OnErrorCallback() {\r\n\t\t\t\t/*...*/\r\n\t\t\t})\r\n\t\t\t.execute();\r\n\t}\r\n\t/*...*/\r\n}\r\n```\r\n\r\nAll the configuration calls are optional and can be omitted when not needed but keep in mind that provided arguments must match the ones declared in your ``UseCase`` method or an error will be raised. It is important to keep in mind that, by default, your callback methods will be executed in the main thread so you can easily update your UI from them.\r\n\r\n####Named use cases\r\n\r\nSometimes you need to specify use cases that are very similar to each other. To avoid creating multiple classes representing every use case configuration, you can create a single ``RosieUseCase`` class with multiple methods. Rosie will be able to identify the use case being called by matching its input parameters. If you create two methods with the ``@UseCase`` annotation that have the same input parameters, you can provide a name to each of them in order to identify them:\r\n\r\n```java\r\npublic class DoSomething extends RosieUseCase {\r\n\tpublic static final String USE_CASE_NAME = \"UseCaseName\";\r\n\tpublic static final String OTHER_USE_CASE_NAME = \"OtherUseCaseName\";\r\n\t@UseCase(name = USE_CASE_NAME) public void doSomething(Object arg) {/*...*/}\r\n\t@UseCase(name = OTHER_USE_CASE_NAME) public void doSomethingElse(Object arg) {/*...*/}\r\n}\r\n```\r\n\r\nEven though using names is not mandatory when the method input parameters are different, it's highly recommended to use them just to make its usage more readable.\r\n\r\nTo call a named use case just configure its name:\r\n\r\n```java\r\npublic class SamplePresenter extends RosiePresenter<SamplePresenter.View> {\r\n\tpublic void callUseCase() {\r\n\t\tcreateUseCaseCall(doSomething)\r\n\t\t\t.args(arg)\r\n\t\t\t.useCaseName(DoSomething.USE_CASE_NAME)\r\n\t\t\t.execute();\r\n\t}\r\n\t/*...*/\r\n}\r\n```\r\n\r\n###Error handling\r\n\r\nErrors can be either manually reported or implicitly notified when an exception is thrown from your use case context. To handle errors, there is a capturing event system that iterates over all your registered ``OnErrorCallback`` implementations and notifies them of the issue. Every callback needs to return a boolean value to inform whether the error has been handled and needs no further management. Callbacks are always called in this specific order:\r\n\r\n1. Use case specific callback; the ones you register while calling a use case.\r\n2. Global callbacks; the ones you can register from your presenter constructor.\r\n\r\nWith this approach you can create an error callback in your presenter that shows a generic error message to your user and create multiple other listeners for specific use cases and/or errors.\r\n\r\nTo register global callbacks from your presenter, call ``registerOnErrorCallback`` in the constructor:\r\n\r\n```java\r\npublic class SamplePresenter extends RosiePresenter<SamplePresenter.View> implements OnErrorCallback {\r\n\tpublic SamplePresenter(UseCaseHandler useCaseHandler) {\r\n\t\tsuper(useCaseHandler);\r\n\t\tregisterOnErrorCallback(this);\r\n\t}\r\n\r\n\t@Override public boolean onError(Error error) {\r\n\t\tgetView().showGenericError();\r\n\t\treturn true;\r\n\t}\r\n}\r\n```\r\n\r\nAs explained in the ``UseCase`` section, you can also register error callbacks for a use case call. Rosie will assign those a higher priority:\r\n\r\n```java\r\npublic class SamplePresenter extends RosiePresenter<SamplePresenter.View> {\r\n\tpublic void callUseCase() {\r\n\t\tcreateUseCaseCall(doSomething)\r\n\t\t\t.args(arg)\r\n\t\t\t.onError(new OnErrorCallback() {\r\n\t\t\t\tgetView().showSpecificError();\r\n\t\t\t\t// The error has been handled\r\n\t\t\t\t// Avoid calling any other error callback by returning true\r\n\t\t\t\treturn true;\r\n\t\t\t})\r\n\t\t\t.execute();\r\n\t}\r\n\t/*...*/\r\n}\r\n```\r\nYou can create your own ErrorFactory implementation to map Exceptions to Errors. In your implementation you can unify your error handling.\r\n\r\n```java\r\npublic class CustomErrorFactory extends ErrorFactory {\r\n\r\n\t@Inject public CustomErrorFactory() {\r\n\t}\r\n\r\n\t@Override public Error create(Exception exception) {\r\n\t\tif (targetException instanceof MyConnectionException) {\r\n\t\t\treturn new ConnectionError();\r\n\t\t}\r\n\t\treturn new UnknownError();\r\n  }\r\n}\r\n```\r\n\r\nRemember to provide your ErrorFactory implementation inside a Dagger module.\r\n\r\n```java\r\n\t@Provides public ErrorHandler providesErrorHandler(CustomErrorFactory errorFactory) {\r\n\t\treturn new ErrorHandler(errorFactory);\r\n\t}\r\n```\r\n\r\n\r\n###Repository\r\n\r\nThe third layer is meant to encapsulate your data sources. To start using it just extend ``RosieRepository`` and configure its data sources in its constructor:\r\n\r\n```java\r\npublic class SampleRepository extends RosieRepository<Key, Value> {\r\n\t@Inject public SampleRepository(SampleApiDataSource sampleApiDataSource,\r\n\t\t\tSampleCacheDataSource sampleCacheDataSource) {\r\n\t\taddReadableDataSources(sampleApiDataSource);\r\n\t\taddCacheDataSources(sampleCacheDataSource);\r\n\t}\r\n}\r\n```\r\n\r\nThere are three different types of data sources and each one has its own interface that you can implement to use it in your repository:\r\n\r\n* ``ReadableDataSource<K, V>``: Defines data sources where you can read values by a given key or retrieving them all.\r\n* ``WriteableDataSource<K, V>``: Defines data sources where you can persist data with operations to add, update or delete values.\r\n* ``CacheDataSource<K, V>``: Defines a mix of readable and writeable data sources to speed up access to your values.\r\n\r\nThere are empty implementations of each data source to simplify your own subclasses by overriding only the methods that make sense in your context. Besides, there is a generic ``InMemoryCacheDataSource`` to store recent values up to a configurable time.\r\n\r\n```java\r\npublic class SampleRepository extends RosieRepository<Key, Value> {\r\n\t@Inject public SampleRepository() {\r\n\tPaginatedCacheDataSource<Key, Value> inMemoryCacheDataSource =\r\n\t\tnew InMemoryCacheDataSource<>(new TimeProvider(), MINUTES.toMillis(5));\r\n\taddCacheDataSources(inMemoryCacheDataSource);\r\n  }\r\n}\r\n```\r\n\r\nUsers of the repositories can retrieve or modify data by using one of the multiple methods available for that matter. There are multiple ways to retrieve and store data using repositories, the following snippet shows some of the most useful:\r\n\r\n```java\r\n// Initialization\r\nKey key = /*...*/; Value value; Collection<Value> values;\r\nRosieRepository<Key, Value> repository = /*...*/;\r\n\r\n// Get a value by its key\r\nvalue = repository.getByKey(key);\r\n// Get a value by its key using only the defined cache\r\nvalue = repository.getByKey(key, ReadPolicy.CACHE_ONLY);\r\n// Get all the available values\r\nvalues = repository.getAll();\r\n// Get all the available values using only readable sources\r\nvalues = repository.getAll(ReadPolicy.READABLE_ONLY);\r\n// Add a new value\r\nrepository.addOrUpdate(value);\r\n// Add a new value only to the first writeable data source that works\r\nrepository.addOrUpdate(value, WritePolicy.WRITE_ONCE);\r\n// Delete a value by its key\r\nrepository.deleteByKey(key);\r\n// Delete all values stored in the repository\r\nrepository.deleteAll();\r\n```\r\n\r\n####Paginated repositories\r\n\r\nFinally, Rosie gives you support for pagination in repositories. If your data is paginated, just extend ``PaginatedRosieRepository`` instead of ``RosieRepository``. You will also need to implement your paginated data sources, ``PaginatedReadableDataSource<V>`` and ``PaginatedCacheDataSource<K, V>``. Once your paginated repository is completely defined and configured you will be able to use it just as a regular repository with additional pagination-related methods:\r\n\r\n```java\r\n// Initialization\r\nKey key = /*...*/; PaginatedCollection<Value> page;\r\nPaginatedRosieRepository<Key, Value> repository = /*...*/;\r\n\r\n// Get a value by its key just as with a regular repository\r\nValue value = repository.getByKey(key);\r\n// Get a page\r\npage = repository.getPage(Page.withOffsetAndLimit(offset, limit));\r\n// Get a page using only the cache data source\r\npage = repository.getPage(Page.withOffsetAndLimit(offset, limit), ReadPolicy.CACHE_ONLY);\r\n```\r\n\r\n**To run the application using real data obtained from the Marvel API create a ``marvel.properties`` file inside the ``sample`` directory and add your public and private key there as follows:**\r\n\r\n```\r\nMARVEL_PUBLIC_KEY=\"YOUR_MARVEL_PUBLIC_KEY\"\r\nMARVEL_PRIVATE_KEY=\"YOUR_MARVEL_PRIVATE_KEY\"\r\n```\r\n\r\nAdd it to your project\r\n----------------------\r\n\r\nInclude the library in your ``build.gradle``\r\n\r\n```groovy\r\ndependencies{\r\n    compile 'com.karumi.rosie:rosie:1.0.0'\r\n}\r\n```\r\n\r\nor to your ``pom.xml`` if you are using Maven\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.karumi.rosie</groupId>\r\n    <artifactId>rosie</artifactId>\r\n    <version>1.0.0</version>\r\n    <type>aar</type>\r\n</dependency>\r\n\r\n```\r\n\r\nDo you want to contribute?\r\n--------------------------\r\n\r\nFeel free to report us or add any useful feature to the library, we will be glad to improve it with your help.\r\n\r\nKeep in mind that your PRs **must** be validated by Travis-CI. Please, run a local build with ``./gradlew checkstyle build connectedCheck`` before submitting your code.\r\n\r\n\r\nLibraries used in this project\r\n------------------------------\r\n\r\n* [JUnit] [junit]\r\n* [Mockito] [mockito]\r\n* [Robolectric] [robolectric]\r\n* [ButterKnife] [butterknife]\r\n* [Dagger] [dagger]\r\n* [Renderers] [renderers]\r\n* [Android Priority Job Queue] [jobqueue]\r\n\r\nLicense\r\n-------\r\n\r\n    Copyright 2015 Karumi\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n[clean]: https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html\r\n[di]: http://martinfowler.com/articles/injection.html\r\n[com]: http://www.oodesign.com/command-pattern.html\r\n[rep]: https://msdn.microsoft.com/en-us/library/ff649690.aspx\r\n[mvp]: http://martinfowler.com/eaaDev/uiArchs.html#Model-view-presentermvp\r\n[sample]: ./art/sample.png\r\n[karumilogo]: ./art/karumilogo.png\r\n[junit]: https://github.com/junit-team/junit\r\n[mockito]: https://github.com/mockito/mockito\r\n[robolectric]: https://github.com/robolectric/robolectric\r\n[dagger]: https://github.com/square/dagger\r\n[butterknife]: https://github.com/JakeWharton/butterknife\r\n[renderers]: https://github.com/pedrovgs/renderers\r\n[jobqueue]: https://github.com/yigit/android-priority-jobqueue\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}